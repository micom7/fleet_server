# ADR-002: Collector — специфікація Modbus Reader

**Статус:** Прийнято
**Дата:** 2026-02-18
**Джерела:** `docs/et7017_register_table.pdf`, `docs/et724_register_table.pdf`

---

## Контекст

Collector опитує три Modbus TCP модулі ICP DAS:
- **ET-7017 × 2** — аналогові входи 4-20 мА (8 каналів кожен, 16 разом)
- **ET-7284 × 1** — лічильник/частота/енкодер (8 каналів)

Потрібно зафіксувати: FC-коди, адреси регістрів, формат сирих значень, конвенцію `raw_min`/`raw_max` у `channel_config`, поведінку при збоях та реакцію на `pg_notify`.

---

## Карта Modbus-регістрів

### ET-7017 — аналоговий вхід (FC04)

| Параметр | Значення |
|---|---|
| Function Code | **04** (Read Input Registers, 3xxxx) |
| Стартова адреса (0-based) | **0** (реєстр 30000 за ICP DAS нотацією) |
| Кількість реєстрів | **8** (канали 0–7) |
| Тип даних | **int16** (signed, -32768 … 32767) |
| Режим даних | Hex mode (за замовчуванням, Coil 00631 = 0) |

**Масштаб для діапазону 4–20 мА (range code 0x07):**

| Raw значення | мА | Примітка |
|---|---|---|
| 0 (0x0000) | 0 мА | нижче нуля — open wire detection |
| 6554 | ~4 мА | нижня робоча межа (6554 = 4/20 × 32767) |
| 32767 (0x7FFF) | 20 мА | повна шкала |

```
mA = raw × 20.0 / 32767
```

**Конвенція `channel_config` для реального обладнання:**
- `raw_min = 6554` — raw при 4 мА (нижня межа датчика)
- `raw_max = 32767` — raw при 20 мА (верхня межа датчика)
- `phys_min`, `phys_max` — фізичні одиниці датчика (наприклад, 0.0 бар … 10.0 бар)

**Конвенція `channel_config` для симулятора:**
- `raw_min = 6400` — симулятор використовує нестандартну шкалу 0–32000 замість 0–32767
- `raw_max = 32000`

> ⚠️ **Різниця симулятор/обладнання:** симулятор ET-7017 повертає значення в шкалі 0–32000,
> реальний модуль — в шкалі 0–32767. Код нормалізації однаковий (формула з `channel_config`),
> але `raw_min`/`raw_max` у `channel_config` мають відрізнятися для симулятора і продакшену.

---

### ET-7284 — лічильник / частота (FC04)

| Параметр | Значення |
|---|---|
| Function Code | **04** (Read Input Registers, 3xxxx) |
| Стартова адреса (0-based) | **16** (0x0010, реєстр 30016 за ICP DAS нотацією) |
| Кількість реєстрів | **16** (8 каналів × 2 реєстри на канал) |
| Тип даних | **uint32** (32-bit беззнаковий, 2 реєстри: Low word + High word) |

**Адреси каналів (0-based):**

| Канал | Low word (адреса) | High word (адреса) | Конфігурація |
|---|---|---|---|
| 0 | 16 | 17 | encoder/counter або frequency |
| 1 | 18 | 19 | encoder/counter або frequency |
| 2 | 20 | 21 | encoder/counter або frequency |
| 3 | 22 | 23 | encoder/counter або frequency |
| 4 | 24 | 25 | encoder/counter або frequency |
| 5 | 26 | 27 | encoder/counter або frequency |
| 6 | 28 | 29 | encoder/counter або frequency |
| 7 | 30 | 31 | encoder/counter або frequency |

**Збірка 32-bit значення (Little-endian word order):**
```python
value_uint32 = (registers[base + 1] << 16) | registers[base]
# base = 16 + channel * 2  (відносно стартової адреси 0)
```

**Одиниці вимірювання за типом каналу:**
- `encoder_counter` → імпульси (uint32, накопичувальний) → нормалізується в метри (див. нижче)
- `encoder_frequency` → Гц (uint32) → нормалізується в м/с

---

### Конвенція нормалізації `encoder_counter` (метри)

Лічильник — необмежений uint32. Стандартна формула лінійно екстраполюється за межі `phys_max`, що є коректною поведінкою для накопичувального сигналу.

**Конвенція `channel_config` для `encoder_counter`:**

| Поле | Значення | Сенс |
|---|---|---|
| `raw_min` | `0` | нуль імпульсів |
| `raw_max` | `PPM` | кількість імпульсів на 1 метр |
| `phys_min` | `0.0` | 0 метрів |
| `phys_max` | `1.0` | 1 метр (масштабний множник) |

```
phys (м) = phys_min + (raw - raw_min) / (raw_max - raw_min) × (phys_max - phys_min)
         = 0.0 + raw / PPM × 1.0
         = raw / PPM
```

При `raw > PPM`: phys > 1.0 — це нормально, метри продовжують зростати.
`raw_max = PPM` — це масштабний коефіцієнт, а не верхня межа діапазону.

**Конвенція `channel_config` для `encoder_frequency`:**

| Поле | Значення | Сенс |
|---|---|---|
| `raw_min` | `0` | 0 Гц |
| `raw_max` | `PPM` | частота в Гц при швидкості 1 м/с |
| `phys_min` | `0.0` | 0 м/с |
| `phys_max` | `1.0` | 1 м/с (масштабний множник) |

```
phys (м/с) = raw / PPM
```

**Приклад:** PPM = 1000 імпульсів/метр, raw = 2500 імпульсів
- counter: phys = 2500 / 1000 = **2.5 м**
- frequency: raw = 500 Гц → phys = 500 / 1000 = **0.5 м/с**

**Конфігурація типу каналу** задається у Holding Register 40032–40039 (по одному на канал):
- `0x50` — Up Counter
- `0x51` — Frequency
- `0x54` — Up/Down Counter (CW/CCW)
- `0x55` — Dir/Pulse (Bi-directional)
- `0x56` — A/B Phase (Quadrant Counting)

> Симулятор виправлено: тепер використовує FC04 (Input Registers), адреса 16. ✅

---

## Цикл опитування Collector

### Структура одного циклу (1 Гц)

```
1. cycle_time = NOW() UTC  ← фіксується ОДИН РАЗ на початку циклу
2. Для кожного модуля (ET7017_1, ET7017_2, ET7284):
   a. Зчитати всі регістри одним запитом (batch read)
   b. Якщо Modbus OK → розпакувати raw values
   c. Якщо Modbus Error → value = None для всіх каналів цього модуля
3. Нормалізувати: phys = phys_min + (raw - raw_min) / (raw_max - raw_min) × (phys_max - phys_min)
4. Батч-інсерт у measurements (1 транзакція, ~17 рядків)
5. ZeroMQ PUB: один пакет {cycle_time, readings[]}
```

**Послідовне читання модулів** (не паралельне) — спрощує обробку помилок і налагодження.

---

## Поведінка при збої Modbus-модуля

**Рішення: публікувати та записувати `null` для каналів недоступного модуля.**

| Ситуація | Поведінка |
|---|---|
| Один модуль недоступний | `value = None` для його каналів; інші модулі опитуються штатно |
| Всі модулі недоступні | Публікується пакет з усіма `value = None`; цикл продовжується |
| Modbus timeout | Логується ERROR; модуль позначається як disconnected; retry через RECONNECT_DELAY_SEC |
| Помилка запису в БД | Логується CRITICAL; пакет у ZeroMQ **публікується** (дані валідні — прочитані з Modbus); в БД цикл не зберігається (розрив в історії) |

**Обґрунтування:**
- Часткові дані (`null`) краще за відсутність рядків: Monitor може відрізнити "нема даних" від "модуль впав"
- Графана коректно відображає NULL як розрив лінії
- Monitor перевіряє `value is None` перед застосуванням правил тривог

---

## Реакція на `pg_notify('config_changed', channel_id)`

**Рішення: повне перезавантаження всіх каналів (`SELECT * FROM channel_config`).**

```python
# При отриманні NOTIFY:
async def on_config_changed(channel_id: str):
    configs = await db.fetch_all_channel_configs()  # перезавантажити ВСЕ
    collector.reload_configs(configs)
    logger.info("Config reloaded (triggered by channel %s)", channel_id)
```

**Обґрунтування:**
- Простіше і безпечніше — виключає edge cases часткового оновлення
- Повне перезавантаження займає < 1 мс (17 рядків)
- Затримка між зміною конфігу і застосуванням — не більше 1 циклу (1 сек)
- `channel_id` у payload не використовується для фільтрації, тільки для логування

---

## requirements.txt (Collector)

Повний набір залежностей:

```
pymodbus>=3.6.0      # Modbus TCP клієнт
psycopg2-binary>=2.9.9  # PostgreSQL + LISTEN/NOTIFY
pyzmq>=25.0.0        # ZeroMQ PUB (шина даних → Monitor, Portal)
python-dotenv>=1.0.0 # Завантаження .env
```

---

## config.txt — усунення суперечності

`config.txt` містив поля `AI_CHANNEL_X_MIN/MAX/UNIT`, які **суперечать DB-first архітектурі**.
Ці поля видалено: вся конфігурація нормалізації зберігається виключно в `channel_config`.

`config.txt` залишає тільки інфраструктурні параметри:
- IP/порти модулів (залежать від середовища: симулятор vs продакшн)
- Параметри опитування (`POLLING_FREQUENCY_HZ`, `MODBUS_TIMEOUT_SEC`, `RECONNECT_DELAY_SEC`)

---

## Що потрібно зробити до реалізації (checklist)

- [x] Виправити симулятор ET-7284: FC03 → FC04, адреса 0 → 16 ✅
- [x] Додати `ZMQ_COLLECTOR_PUB` та `ZMQ_MONITOR_PUB` у `.env` ✅
- [x] Зафіксувати конвенцію нормалізації `encoder_counter` / `encoder_frequency` (варіант A: phys = raw / PPM) ✅
- [ ] Заповнити `channel_config` початковими даними (17 каналів: 16 AI + 1 encoder) — передумова для першого запуску
- [ ] Підтвердити `raw_min`/`raw_max` на реальному обладнанні (або залишити симуляторні значення для dev)
- [ ] Встановити тип каналів ET-7284 через Holding Register 40032 (Up Counter / Frequency / A/B Phase)
